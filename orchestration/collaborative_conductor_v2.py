#!/usr/bin/env python3
"""
Collaborative Conductor V2 - With Project Folder Organization
"""

import subprocess
import asyncio
import json
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List, Optional
import re


class CollaborativeConductor:
    """Orchestrator that creates organized project folders for each task"""
    
    def __init__(self):
        self.tools = {
            'claude': 'claude',  # Claude CLI
        }
        self.output_handlers = []
        self.base_dir = Path.cwd() / 'projects_master'
        self.base_dir.mkdir(exist_ok=True)
        
        # Current project directory
        self.working_dir = None
        self.project_name = None
        
        # Store all communications
        self.communications = []
        
    def add_output_handler(self, handler):
        """Add a handler to receive real-time output"""
        self.output_handlers.append(handler)
        
    def _sanitize_project_name(self, task: str) -> str:
        """Create a safe folder name from the task description"""
        # Extract key words from task
        name = task.lower()
        
        # Remove common words
        stop_words = ['create', 'a', 'an', 'the', 'build', 'make', 'develop', 'implement']
        words = name.split()
        words = [w for w in words if w not in stop_words]
        name = ' '.join(words[:4])  # Take first 4 meaningful words
        
        # Clean up for filesystem
        name = re.sub(r'[^\w\s-]', '', name)
        name = re.sub(r'[-\s]+', '-', name)
        name = name.strip('-')
        
        # Add timestamp for uniqueness
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        return f"{name}_{timestamp}"
        
    def _setup_project_directory(self, task: str):
        """Create a new project directory for this task"""
        self.project_name = self._sanitize_project_name(task)
        self.working_dir = self.base_dir / self.project_name
        self.working_dir.mkdir(exist_ok=True)
        
        # Create subdirectories
        (self.working_dir / 'src').mkdir(exist_ok=True)
        (self.working_dir / 'docs').mkdir(exist_ok=True)
        (self.working_dir / 'tests').mkdir(exist_ok=True)
        
        # Create a README with task info
        readme_content = f"""# {task}

Generated by Collaborative Conductor on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Task Description
{task}

## Project Structure
```
{self.project_name}/
‚îú‚îÄ‚îÄ src/         # Source code files
‚îú‚îÄ‚îÄ docs/        # Documentation and analysis
‚îú‚îÄ‚îÄ tests/       # Test files
‚îî‚îÄ‚îÄ README.md    # This file
```

## Files Generated
_Files will be listed here as they are created_
"""
        (self.working_dir / 'README.md').write_text(readme_content)
        
        print(f"\nüìÅ Created project folder: {self.working_dir}")
        print(f"   Project name: {self.project_name}")
        
    async def broadcast_project_info(self):
        """Send project folder information to output handlers"""
        for handler in self.output_handlers:
            try:
                await handler({
                    'type': 'project_created',
                    'project_name': self.project_name,
                    'project_path': str(self.working_dir),
                    'timestamp': datetime.now().strftime('%H:%M:%S')
                })
            except:
                pass
        
    async def run_tool(self, tool_name: str, args: List[str], agent_name: str = "Agent") -> Dict[str, Any]:
        """Run a CLI tool and capture full output"""
        if tool_name not in self.tools:
            return {'success': False, 'error': f'Unknown tool: {tool_name}'}
            
        # Build command
        tool_cmd = self.tools[tool_name]
        if ' ' in tool_cmd:
            cmd_parts = tool_cmd.split()
            cmd = cmd_parts + args
        else:
            cmd = [tool_cmd] + args
            
        print(f"\n{'='*70}")
        print(f"ü§ñ {agent_name} SPEAKING:")
        print(f"{'='*70}")
        print(f"Command: {' '.join(cmd[:3])}...")
        if len(args) > 1 and '--print' in args:
            # Show the prompt being sent
            prompt = args[-1]
            print(f"\nPROMPT:\n{'-'*70}")
            print(prompt)
            print(f"{'-'*70}\n")
        
        try:
            # Determine appropriate subdirectory based on agent role
            if "Analyst" in agent_name or "Reviewer" in agent_name:
                cwd = str(self.working_dir / 'docs')
            else:
                cwd = str(self.working_dir / 'src')
                
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                stdin=asyncio.subprocess.PIPE,
                cwd=cwd
            )
            
            # Collect all output
            stdout, stderr = await process.communicate()
            
            output = ""
            if stdout:
                output = stdout.decode('utf-8')
                
                # Display the response
                print(f"RESPONSE:")
                print(f"{'-'*70}")
                print(output)
                print(f"{'-'*70}")
                
                # Store communication
                self.communications.append({
                    'agent': agent_name,
                    'timestamp': datetime.now().isoformat(),
                    'prompt': args[-1] if len(args) > 0 else "",
                    'response': output,
                    'type': 'analysis' if '--print' in args else 'action'
                })
                
                # Notify handlers
                for handler in self.output_handlers:
                    try:
                        await handler({
                            'tool': tool_name,
                            'line': f"{agent_name}: {output[:100]}...",
                            'timestamp': datetime.now().strftime('%H:%M:%S')
                        })
                    except:
                        pass
            
            return {
                'success': process.returncode == 0,
                'exit_code': process.returncode,
                'output': output,
                'command': ' '.join(cmd)
            }
            
        except Exception as e:
            print(f"‚ùå Error: {e}")
            return {
                'success': False,
                'error': str(e),
                'output': ''
            }
            
    async def orchestrate(self, task: str):
        """Wrapper method for compatibility with server.py"""
        return await self.orchestrate_with_dialogue(task)
            
    async def orchestrate_with_dialogue(self, task: str):
        """Orchestrate a task with organized project structure"""
        # Set up project directory
        self._setup_project_directory(task)
        await self.broadcast_project_info()
        
        print(f"\nüé≠ COLLABORATIVE ORCHESTRATION: {task}")
        print("="*70)
        print("Watch the AI agents communicate and collaborate!\n")
        
        # Save task context
        context_file = self.working_dir / "docs" / "task_context.md"
        context_file.write_text(f"# Task\n{task}\n\n# Communications Log\n")
        
        # === CONVERSATION 1: Initial Analysis ===
        print("\nüí¨ CONVERSATION 1: Initial Analysis")
        
        claude1_prompt = f"""Analyze this task and create a detailed implementation plan:
{task}

Please provide:
1. Your understanding of the requirements
2. Technical approach you would take
3. File structure needed
4. Key features to implement"""

        result1 = await self.run_tool('claude', [
            '--print',
            '--dangerously-skip-permissions',
            claude1_prompt
        ], "Claude-1 (Analyst)")
        
        # Save Claude1's analysis
        analysis = result1.get('output', '')
        (self.working_dir / "docs" / "claude1_analysis.md").write_text(analysis)
        
        # === CONVERSATION 2: Implementation ===
        print("\nüí¨ CONVERSATION 2: Implementation")
        
        impl_prompt = f"Based on this plan, implement: {task}"
        
        result2 = await self.run_tool('claude', [
            '--dangerously-skip-permissions',
            impl_prompt
        ], "Claude-1 (Implementer)")
        
        # Show what files were created
        print("\nüìÅ Files created by Claude-1:")
        src_files = list((self.working_dir / 'src').iterdir())
        for file in src_files:
            if file.is_file():
                print(f"  ‚úÖ {file.name}")
        
        # === CONVERSATION 3: Peer Review ===
        print("\nüí¨ CONVERSATION 3: Peer Review")
        
        # Get list of implementation files for Claude2 to review
        impl_files = [f for f in (self.working_dir / 'src').iterdir() 
                     if f.is_file() and f.suffix in ['.py', '.js', '.html', '.css']]
        
        if impl_files:
            # Read first implementation file for context
            first_file = impl_files[0]
            file_content = first_file.read_text()[:500] + "..."
            
            review_prompt = f"""Another developer (Claude-1) has implemented: {task}

They created these files in src/: {', '.join(f.name for f in impl_files)}

Here's a preview of {first_file.name}:
{file_content}

Please review the implementation and provide:
1. What works well
2. Potential issues or bugs
3. Specific improvements needed
4. Code quality assessment"""

            result3 = await self.run_tool('claude', [
                '--print',
                '--dangerously-skip-permissions',
                review_prompt
            ], "Claude-2 (Reviewer)")
            
            # Save review
            review = result3.get('output', '')
            (self.working_dir / "docs" / "claude2_review.md").write_text(review)
            
            # === CONVERSATION 4: Improvement Discussion ===
            print("\nüí¨ CONVERSATION 4: Improvement Implementation")
            
            improve_prompt = f"""Based on this review feedback:
{review[:300]}...

Please improve the existing implementation in the src/ directory. Make it better, more robust, and address the feedback."""

            result4 = await self.run_tool('claude', [
                '--dangerously-skip-permissions',
                improve_prompt
            ], "Claude-2 (Improver)")
            
            # === CONVERSATION 5: Final Review ===
            print("\nüí¨ CONVERSATION 5: Final Review")
            
            final_prompt = f"""The implementation for '{task}' has been reviewed and improved by Claude-2.

Please check what improvements were made and provide your final assessment."""

            result5 = await self.run_tool('claude', [
                '--print',
                '--dangerously-skip-permissions',
                final_prompt
            ], "Claude-1 (Final Reviewer)")
        
        # === SUMMARY ===
        print("\n" + "="*70)
        print("üéâ COLLABORATION COMPLETE!")
        print("="*70)
        
        print(f"\nüìä Communication Summary:")
        print(f"  ‚Ä¢ Total exchanges: {len(self.communications)}")
        print(f"  ‚Ä¢ Analysis messages: {sum(1 for c in self.communications if c['type'] == 'analysis')}")
        print(f"  ‚Ä¢ Action messages: {sum(1 for c in self.communications if c['type'] == 'action')}")
        
        # Update README with final file list
        all_files = []
        for subdir in ['src', 'docs', 'tests']:
            subpath = self.working_dir / subdir
            if subpath.exists():
                files = [f for f in subpath.iterdir() if f.is_file()]
                if files:
                    all_files.append(f"\n### {subdir}/")
                    for f in files:
                        size = len(f.read_text())
                        all_files.append(f"- {f.name} ({size} chars)")
        
        readme_path = self.working_dir / 'README.md'
        readme_content = readme_path.read_text()
        readme_content = readme_content.replace(
            "_Files will be listed here as they are created_",
            '\n'.join(all_files)
        )
        readme_path.write_text(readme_content)
        
        print(f"\nüìÅ Project location: {self.working_dir}")
        print(f"üìã Total files created: {len(list(self.working_dir.rglob('*.*')))}")
        
        # Save full communication log
        log_file = self.working_dir / "docs" / "communication_log.json"
        log_file.write_text(json.dumps(self.communications, indent=2))
        print(f"\nüíæ Full communication log saved to: {log_file}")
        
        # Notify handlers of completion
        for handler in self.output_handlers:
            try:
                await handler({
                    'type': 'orchestration_complete',
                    'project_path': str(self.working_dir),
                    'files_created': len(list(self.working_dir.rglob('*.*'))),
                    'timestamp': datetime.now().strftime('%H:%M:%S')
                })
            except:
                pass


async def demo_collaboration():
    """Demo the collaborative conductor"""
    conductor = CollaborativeConductor()
    
    # Run collaboration
    await conductor.orchestrate_with_dialogue(
        "Create a interactive countdown timer web app with start, pause, reset functions"
    )


if __name__ == "__main__":
    print("üöÄ Collaborative Conductor V2 - Project Folder Organization")
    print("Each task creates its own organized project folder\n")
    asyncio.run(demo_collaboration())