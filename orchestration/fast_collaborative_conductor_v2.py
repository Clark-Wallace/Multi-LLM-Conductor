#!/usr/bin/env python3
"""
Fast Collaborative Conductor V2 - With Project Folder Organization
"""

import subprocess
import asyncio
import json
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List, Optional
import concurrent.futures
from functools import partial
import re


class FastCollaborativeConductor:
    """Fast orchestrator with organized project folders"""
    
    def __init__(self):
        self.tools = {
            'claude': 'claude',  # Claude CLI
        }
        self.output_handlers = []
        self.base_dir = Path.cwd() / 'projects_master'
        self.base_dir.mkdir(exist_ok=True)
        
        # Current project directory
        self.working_dir = None
        self.project_name = None
        
        # Store all communications
        self.communications = []
        
        # Thread pool for parallel subprocess execution
        self.executor = concurrent.futures.ThreadPoolExecutor(max_workers=3)
        
    def add_output_handler(self, handler):
        """Add a handler to receive real-time output"""
        self.output_handlers.append(handler)
        
    def _sanitize_project_name(self, task: str) -> str:
        """Create a safe folder name from the task description"""
        # Extract key words from task
        name = task.lower()
        
        # Remove common words
        stop_words = ['create', 'a', 'an', 'the', 'build', 'make', 'develop', 'implement']
        words = name.split()
        words = [w for w in words if w not in stop_words]
        name = ' '.join(words[:4])  # Take first 4 meaningful words
        
        # Clean up for filesystem
        name = re.sub(r'[^\w\s-]', '', name)
        name = re.sub(r'[-\s]+', '-', name)
        name = name.strip('-')
        
        # Add timestamp for uniqueness
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        return f"{name}_{timestamp}"
        
    def _setup_project_directory(self, task: str):
        """Create a new project directory for this task"""
        self.project_name = self._sanitize_project_name(task)
        self.working_dir = self.base_dir / self.project_name
        self.working_dir.mkdir(exist_ok=True)
        
        # Create subdirectories
        (self.working_dir / 'src').mkdir(exist_ok=True)
        (self.working_dir / 'docs').mkdir(exist_ok=True)
        
        # Create a README with task info
        readme_content = f"""# {task}

Generated by Fast Collaborative Conductor on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Task Description
{task}

## Project Structure
```
{self.project_name}/
‚îú‚îÄ‚îÄ src/         # Source code files
‚îú‚îÄ‚îÄ docs/        # Documentation and analysis
‚îî‚îÄ‚îÄ README.md    # This file
```

## Generation Mode: FAST (Parallel Execution)
"""
        (self.working_dir / 'README.md').write_text(readme_content)
        
        print(f"\nüìÅ Created project folder: {self.working_dir}")
        
    async def broadcast_project_info(self):
        """Send project folder information to output handlers"""
        for handler in self.output_handlers:
            try:
                await handler({
                    'type': 'project_created',
                    'project_name': self.project_name,
                    'project_path': str(self.working_dir),
                    'timestamp': datetime.now().strftime('%H:%M:%S')
                })
            except:
                pass
        
    def _run_subprocess_sync(self, cmd: List[str], agent_name: str, working_dir: str) -> Dict[str, Any]:
        """Synchronous subprocess execution for thread pool"""
        try:
            start_time = datetime.now()
            
            # Run subprocess
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                cwd=working_dir,
                timeout=30  # Add timeout to prevent hanging
            )
            
            duration = (datetime.now() - start_time).total_seconds()
            
            return {
                'success': result.returncode == 0,
                'output': result.stdout,
                'error': result.stderr,
                'agent': agent_name,
                'duration': duration,
                'command': ' '.join(cmd[:3]) + '...'
            }
            
        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'error': 'Command timed out after 30 seconds',
                'agent': agent_name,
                'duration': 30.0
            }
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'agent': agent_name,
                'duration': 0.0
            }
            
    async def run_parallel_tools(self, tasks: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Run multiple Claude instances in parallel"""
        loop = asyncio.get_event_loop()
        
        # Create tasks for parallel execution
        futures = []
        for task in tasks:
            cmd = ['claude'] + task['args']
            
            # Determine working directory based on task type
            if 'analysis' in task.get('type', '') or 'design' in task.get('type', ''):
                working_dir = str(self.working_dir / 'docs')
            else:
                working_dir = str(self.working_dir / 'src')
                
            future = loop.run_in_executor(
                self.executor,
                partial(self._run_subprocess_sync, cmd, task['agent_name'], working_dir)
            )
            futures.append(future)
            
        # Wait for all tasks to complete
        results = await asyncio.gather(*futures)
        
        # Process results
        for i, result in enumerate(results):
            task = tasks[i]
            
            # Broadcast output
            for handler in self.output_handlers:
                await handler({
                    'tool': 'claude',
                    'line': f"{task['agent_name']}: {result.get('output', '')[:100]}...",
                    'timestamp': datetime.now().strftime('%H:%M:%S')
                })
                
            # Store communication
            self.communications.append({
                'agent': task['agent_name'],
                'timestamp': datetime.now().isoformat(),
                'prompt': task.get('prompt', ''),
                'response': result.get('output', ''),
                'duration': result.get('duration', 0)
            })
            
        return results
        
    async def orchestrate(self, task: str):
        """Wrapper method for compatibility with server.py"""
        return await self.fast_orchestrate(task)
        
    async def fast_orchestrate(self, task: str):
        """Fast orchestration with parallel execution and project folders"""
        # Set up project directory
        self._setup_project_directory(task)
        await self.broadcast_project_info()
        
        print(f"\n‚ö° FAST COLLABORATIVE ORCHESTRATION: {task}")
        print("="*70)
        
        start_time = datetime.now()
        
        # Prepare parallel tasks
        parallel_tasks = [
            {
                'agent_name': 'Claude-Analyst',
                'prompt': f"Analyze and plan: {task}",
                'args': ['--print', '--dangerously-skip-permissions', f"Analyze and plan: {task}"],
                'type': 'analysis'
            },
            {
                'agent_name': 'Claude-Designer',
                'prompt': f"Design architecture for: {task}",
                'args': ['--print', '--dangerously-skip-permissions', f"Design architecture for: {task}"],
                'type': 'design'
            }
        ]
        
        # Phase 1: Parallel Analysis (2 agents work simultaneously)
        print("\n‚ö° Phase 1: Parallel Analysis & Design")
        analysis_results = await self.run_parallel_tools(parallel_tasks)
        
        # Save analysis results
        for i, result in enumerate(analysis_results):
            if result.get('success'):
                filename = f"{parallel_tasks[i]['agent_name'].lower().replace('-', '_')}_output.md"
                (self.working_dir / 'docs' / filename).write_text(result.get('output', ''))
        
        # Phase 2: Quick Implementation (based on combined insights)
        print("\n‚ö° Phase 2: Rapid Implementation")
        
        # Combine insights from parallel analysis
        combined_insights = "\n".join([
            f"{r.get('agent', 'Unknown')}: {r.get('output', '')[:200]}..."
            for r in analysis_results if r.get('success')
        ])
        
        impl_task = {
            'agent_name': 'Claude-Implementer',
            'prompt': f"Implement {task} based on these insights:\n{combined_insights}",
            'args': ['--dangerously-skip-permissions', f"Implement {task}"],
            'type': 'implementation'
        }
        
        impl_results = await self.run_parallel_tools([impl_task])
        
        # Phase 3: Quick validation
        print("\n‚ö° Phase 3: Rapid Validation")
        
        # Check created files
        created_files = list((self.working_dir / 'src').glob("*.*"))
        print(f"\n‚úÖ Created {len(created_files)} source files")
        
        for file in created_files[:5]:  # Show first 5 files
            print(f"  ‚Ä¢ {file.name}")
            
        # Summary
        total_time = (datetime.now() - start_time).total_seconds()
        print(f"\n‚ö° Collaboration completed in {total_time:.1f} seconds!")
        print(f"üìÅ Project location: {self.working_dir}")
        
        # Update README with file list
        readme_path = self.working_dir / 'README.md'
        readme_content = readme_path.read_text()
        
        file_list = ["\n## Files Generated"]
        for subdir in ['src', 'docs']:
            subpath = self.working_dir / subdir
            files = list(subpath.glob("*.*"))
            if files:
                file_list.append(f"\n### {subdir}/")
                for f in files:
                    size = len(f.read_text()) if f.suffix in ['.py', '.js', '.html', '.css', '.md'] else f.stat().st_size
                    file_list.append(f"- {f.name} ({size} bytes)")
        
        readme_content += '\n'.join(file_list)
        readme_content += f"\n\n## Performance\nGenerated in {total_time:.1f} seconds using parallel execution."
        readme_path.write_text(readme_content)
        
        # Save communication log
        log_file = self.working_dir / "docs" / "fast_communication_log.json"
        log_file.write_text(json.dumps(self.communications, indent=2))
        
        # Notify completion
        for handler in self.output_handlers:
            try:
                await handler({
                    'type': 'orchestration_complete',
                    'project_path': str(self.working_dir),
                    'files_created': len(created_files),
                    'duration': total_time,
                    'timestamp': datetime.now().strftime('%H:%M:%S')
                })
            except:
                pass
        
        return {
            'success': True,
            'duration': total_time,
            'files_created': len(created_files),
            'communications': len(self.communications),
            'project_path': str(self.working_dir)
        }


async def demo_fast_collaboration():
    """Demo the fast collaborative conductor"""
    conductor = FastCollaborativeConductor()
    
    # Run fast collaboration
    await conductor.fast_orchestrate(
        "Create a simple todo list web app"
    )


if __name__ == "__main__":
    print("‚ö° Fast Collaborative Conductor V2 - Project Folder Organization")
    print("Fast parallel execution with organized project structure\n")
    asyncio.run(demo_fast_collaboration())